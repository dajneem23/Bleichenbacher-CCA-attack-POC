

# This file was *autogenerated* from the file bb98_graphic.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_17 = Integer(17); _sage_const_0 = Integer(0); _sage_const_8 = Integer(8); _sage_const_0x02 = Integer(0x02); _sage_const_3 = Integer(3); _sage_const_100 = Integer(100); _sage_const_512 = Integer(512); _sage_const_0x6c6f6c = Integer(0x6c6f6c)# setup
import os
def generate_keypair(size_N_in_bits):
    size_prime = _sage_const_1  << (size_N_in_bits / _sage_const_2 )
    while True:
        p = random_prime(size_prime)
        q = random_prime(size_prime)
        N = p * q
        phi = (p-_sage_const_1 )*(q-_sage_const_1 )
        e = _sage_const_17 
        if gcd(e, phi) != _sage_const_1 :
            continue
        d = inverse_mod(e, phi) # will sometimes not work, generate another setup?
        break
    return e, d, N

# helper
def get_byte_length(message):
    res = _sage_const_0 
    if (len(bin(message)) - _sage_const_2 ) % _sage_const_8  != _sage_const_0 :
        res += _sage_const_1 
    res += (len(bin(message)) - _sage_const_2 ) // _sage_const_8 
    return res

# pad plaintext [00, 02, randoms, 00, messsage] of len target_length
def padding(message, target_length):
    # 02
    res = _sage_const_0x02  << _sage_const_8  * (target_length - _sage_const_2 )
    # random
    random_pad = os.urandom(target_length - _sage_const_3  - get_byte_length(message))
    for idx, val in enumerate(random_pad):
        res += val << (len(random_pad) - idx + get_byte_length(message)) * _sage_const_8 
    # 00
    # message
    res += message

    return res

# a length oracle
def oracle_length(c, d, N):
    p = power_mod(c, d, N)
    return get_byte_length(p)

# a padding oracle
def oracle_padding(c, d, N):
    p = power_mod(c, d, N)
    if get_byte_length(p) != get_byte_length(N) - _sage_const_1 :
        return False
    if p >> ((get_byte_length(p) -_sage_const_1 )) * _sage_const_8  != _sage_const_0x02 : # this is not correct
        return False
    return True

import sys

def print_meta(text):
    sys.stdout.write("=============== ")
    sys.stdout.write(text)
    sys.stdout.write(" ================")
    sys.stdout.write('\n')
    sys.stdout.flush()

def print_line(min, max, m, ranges):
#    print min, max, m, ranges
    # init
    to_draw = {}

    # - min -> 0
    # - max -> 100
    dist = max - min
    # calculate where ranges are
    l = ord('a')
    for r in ranges:
        down = round((r[_sage_const_0 ]-min)*_sage_const_100 /dist)
        up = round((r[_sage_const_1 ]-min)*_sage_const_100 /dist)
        for i in range(down, up+_sage_const_1 ):
            if i == down:
                to_draw[i] = "["
            elif i == up:
                to_draw[i] = "]"
            else:
                to_draw[i] = chr(l)
        l += _sage_const_1 
    # m
    pos_m = round((m-min)*_sage_const_100 /dist)
    to_draw[pos_m-_sage_const_1 ] = "["
    to_draw[pos_m] = "m"
    to_draw[pos_m+_sage_const_1 ] = "]"
    # print
    for i in range(_sage_const_100 ):
        if i in to_draw:
           sys.stdout.write(to_draw[i])
        else:
            sys.stdout.write('-')
    sys.stdout.write('\n')
    sys.stdout.flush()

def bleichenbacher_padding():
    # time
    import time
    start_time = time.time()
    # setup
    e, d, N = generate_keypair(_sage_const_512 )
    N_size = get_byte_length(N)
    plaintext = _sage_const_0x6c6f6c  # "lol"
    padded = padding(plaintext, N_size)
    print("to find:", padded)
    ciphertext = power_mod(padded, e, N)

    # setup attack
    N_bit_length = (get_byte_length(N) - _sage_const_2 ) * _sage_const_8 
    B = _sage_const_1  << N_bit_length

    # debug
    print_meta("start")
    min_n = _sage_const_0 
    max_n = N
    print_line(min_n, max_n, padded, [])
    
    # attack
    previous_steps = [(_sage_const_2 *B, _sage_const_3 *B-_sage_const_1 )]
    mult = ceil(N / (_sage_const_3  * B)) - _sage_const_1 
    i = _sage_const_1 
    number_msg = _sage_const_0 

    while True:
        # debug
        print_meta("message #" + str(i))
        print_meta("zooming in")

        min_n = previous_steps[_sage_const_0 ][_sage_const_0 ]
        max_n = previous_steps[_sage_const_0 ][_sage_const_1 ]
        for r in previous_steps: # min_n, max_n based on previous step
            if r[_sage_const_0 ] < min_n:
                min_n = r[_sage_const_0 ]
            if r[_sage_const_1 ] > max_n:
                max_n = r[_sage_const_1 ]

        print_line(min_n, max_n, padded, previous_steps)

        # find a valid padding
        c2 = _sage_const_0 
        if i > _sage_const_1  and len(previous_steps) == _sage_const_1 :
            previous_mult = mult
            ri = floor(_sage_const_2  * (previous_steps[_sage_const_0 ][_sage_const_1 ]*previous_mult - _sage_const_2  * B) / N)
            found = False
            while True:
                mult = ceil((_sage_const_2 *B+ri*N) / previous_steps[_sage_const_0 ][_sage_const_1 ]) - _sage_const_1 
                mult_max = ceil((_sage_const_3 *B+ri*N)/previous_steps[_sage_const_0 ][_sage_const_0 ])
                while mult < mult_max:
                    mult += _sage_const_1 
                    c2 = (ciphertext * power_mod(mult, e, N)) % N
                    number_msg += _sage_const_1 
                    if oracle_padding(c2, d, N):
                        found = True
                        break
                if found:
                    break
                ri += _sage_const_1 
                
        else:
            while not oracle_padding(c2, d, N):
                number_msg += _sage_const_1 
                mult += _sage_const_1  
                c2 = (ciphertext * power_mod(mult, e, N)) % N
        # debug
#        print "found a valid padding", c2
#        raw_input("press a key to enter next step...\n")
        # compute the new set of intervals
        new_interval = []
        for interval in previous_steps:
            min_range = (interval[_sage_const_0 ] * mult - _sage_const_3  * B + _sage_const_1 ) // N
            max_range = (interval[_sage_const_1 ] * mult - _sage_const_2  * B) // N
#            print max_range + 1 - min_range, "possible r's"
#            print interval[0]
#            print interval[1]
            possible_r = min_range
#            print max_range + 1
            while possible_r < max_range + _sage_const_1 :
                new_min = max(interval[_sage_const_0 ], ceil((_sage_const_2 *B+possible_r*N)/mult))
                new_max = min(interval[_sage_const_1 ], floor((_sage_const_3 *B-_sage_const_1 +possible_r*N)/mult))
                if new_min > interval[_sage_const_1 ] or new_max < interval[_sage_const_0 ]:
                    possible_r += _sage_const_1 
                    continue
                # found?
                if new_max == new_min:
                    print_meta("found!")
                    print(new_min)
                    print_meta("did we find that?")
                    print(padded)
                    print_meta("stats")
                    print("messages:", number_msg)
                    import time
                    print("seconds:", time.time() - start_time)
                    return new_min
                # nope
                new_interval.append((new_min, new_max))
#                print ""
                possible_r += _sage_const_1 
        # debug
        print_meta("reducing range")
        print_line(min_n, max_n, padded, new_interval)

        #
        previous_steps = new_interval
        i += _sage_const_1 
        # debug
#        print "\n"
#        print len(previous_steps), "potential intervals left:"
#        for interval in previous_steps:
#            print " - [", interval[0], ",", interval[1], "]"
#        print "\n"

if __name__ == "__main__":
    bleichenbacher_padding()

