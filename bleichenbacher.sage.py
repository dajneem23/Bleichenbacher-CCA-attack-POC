

# This file was *autogenerated* from the file bleichenbacher.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_17 = Integer(17); _sage_const_0 = Integer(0); _sage_const_8 = Integer(8); _sage_const_0x02 = Integer(0x02); _sage_const_3 = Integer(3); _sage_const_1024 = Integer(1024); _sage_const_0x6c6f6c = Integer(0x6c6f6c); _sage_const_2048 = Integer(2048); _sage_const_10 = Integer(10)# setup
import os
def generate_keypair(size_N_in_bits):
    size_prime = _sage_const_1  << (size_N_in_bits / _sage_const_2 )
    while True:
        p = random_prime(size_prime)
        q = random_prime(size_prime)
        N = p * q
        phi = (p-_sage_const_1 )*(q-_sage_const_1 )
        e = _sage_const_17 
        if gcd(e, phi) != _sage_const_1 :
            continue
        d = inverse_mod(e, phi) # will sometimes not work, generate another setup?
        break
    return e, d, N

# helper
def get_byte_length(message):
    res = _sage_const_0 
    if (len(bin(message)) - _sage_const_2 ) % _sage_const_8  != _sage_const_0 :
        res += _sage_const_1 
    res += (len(bin(message)) - _sage_const_2 ) // _sage_const_8 
    return res

# pad plaintext [00, 02, randoms, 00, messsage] of len target_length
def padding(message, target_length):
    # 02
    res = _sage_const_0x02  << _sage_const_8  * (target_length - _sage_const_2 )
    # random
    random_pad = os.urandom(target_length - _sage_const_3  - get_byte_length(message))
    for idx, val in enumerate(random_pad):
        res += val << (len(random_pad) - idx + get_byte_length(message)) * _sage_const_8 
    # 00
    # message
    res += message

    return res

# a length oracle
def oracle_length(c, d, N):
    p = power_mod(c, d, N)
    return get_byte_length(p)

# a padding oracle
def oracle_padding(c, d, N):
    p = power_mod(c, d, N)
    if get_byte_length(p) != get_byte_length(N) - _sage_const_1 :
        return False
    if p >> ((get_byte_length(p) -_sage_const_1 )) * _sage_const_8  != _sage_const_0x02 : # this is not correct
        return False
    return True


def bleichenbacher_padding():
    # time
    import time
    start_time = time.time()
    # setup
    e, d, N = generate_keypair(_sage_const_1024 )
    N_size = get_byte_length(N)
    plaintext = _sage_const_0x6c6f6c  # "lol"
    padded = padding(plaintext, N_size)
    print("to find:", padded)
    ciphertext = power_mod(padded, e, N)

    # setup attack
    N_bit_length = (get_byte_length(N) - _sage_const_2 ) * _sage_const_8 
    B = _sage_const_1  << N_bit_length
    print(hex(padded))
    print(hex(B))
    
    # attack
    previous_steps = [(_sage_const_2 *B, _sage_const_3 *B-_sage_const_1 )]
    mult = ceil(N / (_sage_const_3  * B)) - _sage_const_1 
    i = _sage_const_1 
    while True:
        # debug
        print("Entering step", i)
        # find a valid padding
        c2 = _sage_const_0 
        if i > _sage_const_1  and len(previous_steps) == _sage_const_1 :
            previous_mult = mult
            ri = floor(_sage_const_2  * (previous_steps[_sage_const_0 ][_sage_const_1 ]*previous_mult - _sage_const_2  * B) / N)
            found = False
            while True:
                mult = ceil((_sage_const_2 *B+ri*N) / previous_steps[_sage_const_0 ][_sage_const_1 ]) - _sage_const_1 
                mult_max = ceil((_sage_const_3 *B+ri*N)/previous_steps[_sage_const_0 ][_sage_const_0 ])
                while mult < mult_max:
                    mult += _sage_const_1 
                    c2 = (ciphertext * power_mod(mult, e, N)) % N
                    if oracle_padding(c2, d, N):
                        found = True
                        break
                if found:
                    break
                ri += _sage_const_1 
                
        else:
            while not oracle_padding(c2, d, N):
                mult += _sage_const_1  
                c2 = (ciphertext * power_mod(mult, e, N)) % N
        # debug
        print("found a valid padding", c2)
        # compute the new set of intervals
        new_interval = []
        for interval in previous_steps:
            min_range = (interval[_sage_const_0 ] * mult - _sage_const_3  * B + _sage_const_1 ) // N
            max_range = (interval[_sage_const_1 ] * mult - _sage_const_2  * B) // N
            print(max_range + _sage_const_1  - min_range, "possible r's")
            print(interval[_sage_const_0 ])
            print(interval[_sage_const_1 ])
            possible_r = min_range
            print(max_range + _sage_const_1 )
            while possible_r < max_range + _sage_const_1 :
                new_min = max(interval[_sage_const_0 ], ceil((_sage_const_2 *B+possible_r*N)/mult))
                new_max = min(interval[_sage_const_1 ], floor((_sage_const_3 *B-_sage_const_1 +possible_r*N)/mult))
                if new_min > interval[_sage_const_1 ] or new_max < interval[_sage_const_0 ]:
                    possible_r += _sage_const_1 
                    continue
                # found?
                if new_max == new_min:
                    print("found!")
                    print(new_min)
                    print("did we find that?")
                    print(padded)
                    print("took", time.time() - start_time, "seconds")
                    return
                # nope
                new_interval.append((new_min, new_max))
                print ""
                possible_r += _sage_const_1 
        previous_steps = new_interval
        i += _sage_const_1 
        # debug
        print("\n")
        print(len(previous_steps), "potential intervals left:")
        for interval in previous_steps:
            print(" - [", interval[_sage_const_0 ], ",", interval[_sage_const_1 ], "]")
        print("\n")

def bleichenbacher_length():
    # time
    import time
    start_time = time.time()
    # setup
    e, d, N = generate_keypair(_sage_const_2048 )
    N_size = get_byte_length(N)
    plaintext = _sage_const_0x6c6f6c  # "lol"
    padded = padding(plaintext, N_size)
    print("to find:", padded)
    ciphertext = power_mod(padded, e, N)

    # setup attack
    N_byte_length = get_byte_length(N)
    N_bit_length = (N_byte_length - _sage_const_2 ) * _sage_const_8 
    B = _sage_const_1  << N_bit_length
    print(hex(padded))
    print(hex(B))
    
    # attack
    previous_steps = [(_sage_const_2 *B, _sage_const_3 *B-_sage_const_1 )]
    mult = ceil(N / (_sage_const_3  * B)) - _sage_const_1  # TODO: find a more relevant range
    i = _sage_const_1 
    while True:
        # debug
        print("Entering step", i)
        # find a valid padding
        c2 = _sage_const_0 
        if i > _sage_const_1  and len(previous_steps) == _sage_const_1 :
            print("entering step 2c.")
            nn = N_byte_length - _sage_const_2  # set it like that ...
            previous_mult = mult
            ri = floor(_sage_const_2  * (previous_steps[_sage_const_0 ][_sage_const_1 ]*previous_mult - _sage_const_2 **(_sage_const_8 *(nn-_sage_const_1 ))) / N)
            found = False
            while True:
                mult = ceil((_sage_const_2 **(_sage_const_8 *(nn-_sage_const_1 ))+ri*N) / previous_steps[_sage_const_0 ][_sage_const_1 ]) - _sage_const_1 
                mult_max = ceil((_sage_const_2 **(_sage_const_8 *nn)-_sage_const_1 +ri*N)/previous_steps[_sage_const_0 ][_sage_const_0 ])
                while mult < mult_max:
                    mult += _sage_const_1 
                    c2 = (ciphertext * power_mod(mult, e, N)) % N
                    if oracle_length(c2, d, N) == nn:
                        found = True
                        break
                if found:
                    break
                ri += _sage_const_1 
                
        else:
            print("entering step 2a or 2b.")
            nn = N_byte_length + _sage_const_10 
            while not(nn < N_byte_length - _sage_const_1 ):
                mult += _sage_const_1  
                c2 = (ciphertext * power_mod(mult, e, N)) % N
                nn = oracle_length(c2, d, N)
        # debug
        print("found a valid padding", c2)
        # compute the new set of intervals
        new_interval = []
        for interval in previous_steps:
            min_range = (interval[_sage_const_0 ]*mult - _sage_const_2 **(_sage_const_8 *nn) - _sage_const_1 ) // N
            max_range = (interval[_sage_const_1 ]*mult - _sage_const_2 **(_sage_const_8 *(nn-_sage_const_1 ))) // N
            print("min, max range for r:", min_range, max_range + _sage_const_1 )
            print(max_range + _sage_const_1  - min_range, "possible r's")
            print(interval[_sage_const_0 ])
            print(interval[_sage_const_1 ])
            possible_r = min_range

            while possible_r < max_range + _sage_const_1 :
                new_min = max(interval[_sage_const_0 ], ceil((_sage_const_2 **(_sage_const_8 *(nn-_sage_const_1 ))+possible_r*N)/mult))
                new_max = min(interval[_sage_const_1 ], floor((_sage_const_2 **(_sage_const_8 *nn)-_sage_const_1 +possible_r*N)/mult))
                # if intersection of range doesn't exist, skip the new range
                if new_min > interval[_sage_const_1 ] or new_max < interval[_sage_const_0 ]:
                    possible_r += _sage_const_1 
                    continue
                # found?
                if new_max == new_min:
                    print "found!"
                    print new_min
                    print "did we find that?"
                    print padded
                    print "took", time.time() - start_time, "seconds"
                    return
                # nope
                new_interval.append((new_min, new_max))
                possible_r += _sage_const_1 
        previous_steps = new_interval
        i += _sage_const_1 
        # debug
        print("\n")
        print(len(previous_steps), "potential intervals left:")
        for interval in previous_steps:
            print(" - [", interval[_sage_const_0 ], ",", interval[_sage_const_1 ], "]")
        print("\n")


#    
if __name__ == "__main__":
    # Use the faster padding-oracle variant for a quick demo
    bleichenbacher_padding()
    # To try the length-oracle variant (slower), switch to:
    # bleichenbacher_length()

